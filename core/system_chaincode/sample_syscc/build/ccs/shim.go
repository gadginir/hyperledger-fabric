/* Generated by chaintool.  DO NOT EDIT */

package ccs

import (
	"errors"
	"regexp"
	"strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	"github.com/hyperledger/fabric/core/system_chaincode/api"
	"github.com/hyperledger/fabric/core/system_chaincode/sample_syscc/build/ccs/stub"
)

type Interfaces map[string]interface{}
type Dispatchers map[string]stub.Dispatcher

type ShimHandler struct {
	dispatchers Dispatchers
}

var txnre = regexp.MustCompile("([a-zA-Z0-9.]*)/txn/([0-9]*)")
var queryre = regexp.MustCompile("([a-zA-Z0-9.]*)/query/([0-9]*)")

// Initialization function, called only once
func (t *ShimHandler) Init(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	if len(args) != 1 {
		return nil, errors.New("Expected exactly one argument")
	}

	if function != "init" {
		return nil, errors.New("Function must be \"init\"")
	}

	dispatcher, ok := t.dispatchers["appinit"]
	if !ok {
		return nil, errors.New("Interface not found")
	}

	return dispatcher.DispatchTxn(stub, 1, args[0])
}

// Callback representing the invocation of a chaincode
func (t *ShimHandler) Invoke(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	if len(args) != 1 {
		return nil, errors.New("Expected exactly one argument")
	}

	re := txnre
	spec := re.FindAllStringSubmatch(function, -1)
	if spec == nil {
		return nil, errors.New("Could not parse function name")
	}

	dispatcher, ok := t.dispatchers[spec[0][1]]
	if !ok {
		return nil, errors.New("Interface not found")
	}

	index, err := strconv.Atoi(spec[0][2])
	if err != nil {
		return nil, errors.New("Could not convert function index")
	}

	return dispatcher.DispatchTxn(stub, index, args[0])
}

// Callback representing the query of a chaincode
func (t *ShimHandler) Query(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	if len(args) != 1 {
		return nil, errors.New("Expected exactly one argument")
	}

	re := queryre
	spec := re.FindAllStringSubmatch(function, -1)
	if spec == nil {
		return nil, errors.New("Could not parse function name")
	}

	dispatcher, ok := t.dispatchers[spec[0][1]]
	if !ok {
		return nil, errors.New("Interface not found")
	}

	index, err := strconv.Atoi(spec[0][2])
	if err != nil {
		return nil, errors.New("Could not convert function index")
	}

	return dispatcher.DispatchQuery(stub, index, args[0])
}

func (t *ShimHandler) addDispatcher(name string, interfaces Interfaces) error {
	intf, ok := interfaces[name]
	if !ok {
		return errors.New("Interface not found")
	}

	dispatcher, err := stub.Create(name, intf)
	if err != nil {
		return err
	}

	t.dispatchers[name] = dispatcher
	return nil
}

func Start(interfaces Interfaces) error {

	handler := &ShimHandler{dispatchers: make(Dispatchers)}

	// Validate all of the interfaces
	if err := handler.addDispatcher("appinit", interfaces); err != nil {
		return err
	}
	if err := handler.addDispatcher("org.hyperledger.chaincode.sample_syscc", interfaces); err != nil {
		return err
	}

	api.RegisterSysCC("github.com/hyperledger/fabric/core/system_chaincode/sample_syscc", handler)
	return nil
}
